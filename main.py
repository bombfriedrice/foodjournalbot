import os
import schedule
import time
from threading import Thread
from telegram import Update, Bot
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
from dotenv import load_dotenv
import openai
from google.oauth2 import service_account
from googleapiclient.discovery import build

# Load environment variables from .env file
load_dotenv()

# Retrieve the bot token, OpenAI API key, spreadsheet ID, service account file path, and chat ID from environment variables
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
SPREADSHEET_ID = os.getenv('SPREADSHEET_ID')
SERVICE_ACCOUNT_FILE = os.getenv('SERVICE_ACCOUNT_FILE')
CHAT_ID = os.getenv('CHAT_ID')

# Initialize the bot
bot = Bot(token=TELEGRAM_TOKEN)

# Retrieve user IDs from environment variables
USER_ID_RAQUEL = os.getenv('USER_ID_RAQUEL')
USER_ID_MOM = os.getenv('USER_ID_MOM')
USER_ID_RJ = os.getenv('USER_ID_RJ')

# Initialize OpenAI API client
openai.api_key = OPENAI_API_KEY

# Initialize Google Sheets API client
credentials = service_account.Credentials.from_service_account_file(
    SERVICE_ACCOUNT_FILE,
    scopes=["https://www.googleapis.com/auth/spreadsheets"]
)
sheets_service = build('sheets', 'v4', credentials=credentials)

# Mapping of Telegram user IDs to Google Sheet tabs
user_tab_mapping = {
    USER_ID_RAQUEL: "Raquel",  # Raquel's user ID and tab name
    USER_ID_MOM: "Mom",        # Use "Mom" as the tab name for Maria
    USER_ID_RJ: "RJ"           # RJ's user ID and tab name
}

# Dictionary to store user input temporarily
user_data = {}

def get_user_tab(user_id):
    """
    Retrieve the tab name for the given user ID.
    
    :param user_id: The Telegram user ID.
    :return: The name of the tab associated with the user ID.
    """
    return user_tab_mapping.get(user_id, None)

def get_gpt4o_mini_response(user_input, context):
    """
    Generate a response from GPT-4o Mini using OpenAI's chat completions API.
    
    :param user_input: The input message from the user.
    :param context: Additional context or instructions for the AI model.
    :return: A response generated by the AI model.
    """
    response = openai.ChatCompletion.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": user_input},
            {"role": "system", "content": context}
        ],
        max_tokens=150,
        temperature=0.7
    )
    return response.choices[0].message['content'].strip()

def append_to_sheet(tab_name, data):
    """
    Append a row of data to the specified tab in the Google Sheet.
    
    :param tab_name: The name of the tab to append data to.
    :param data: A list of data to append as a new row.
    """
    sheet = sheets_service.spreadsheets()
    request = sheet.values().append(
        spreadsheetId=SPREADSHEET_ID,
        range=f"{tab_name}!A1",
        valueInputOption="USER_ENTERED",
        insertDataOption="INSERT_ROWS",
        body={"values": [data]}
    )
    request.execute()

def start(update: Update, context: CallbackContext) -> None:
    """
    Handle the /start command. Send a welcome message to the user.
    
    :param update: The incoming update from Telegram.
    :param context: The context of the callback.
    """
    update.message.reply_text('Hello! I am your food journal bot. How can I assist you today?')

def handle_message(update: Update, context: CallbackContext):
    """
    Handle incoming messages and guide the user through data entry.
    
    :param update: The incoming update from Telegram.
    :param context: The context of the callback.
    """
    chat_id = update.message.chat_id
    user_id = update.message.from_user.id

    # Initialize user data if not present
    if user_id not in user_data:
        user_data[user_id] = {'step': 0, 'data': []}
        print(f"Initialized user data for user_id: {user_id}")

    # Define prompts for each step
    prompts = [
        "Please enter the Date (e.g., YYYY-MM-DD):",
        "What was the Meal/Snack?",
        "What time did you have it?",
        "What Food & Beverages did you consume?",
        "What was the Portion Size?",
        "Please send a photo of your meal.",
        "Any Tolerance & Symptoms?",
        "Any Additional Notes?"
    ]

    # Get the current step
    step = user_data[user_id]['step']
    print(f"Current step for user_id {user_id}: {step}")

    # Handle photo input for step 5
    if step == 5 and update.message.photo:
        photo_file_id = update.message.photo[-1].file_id
        user_data[user_id]['data'].append(photo_file_id)
        user_data[user_id]['step'] += 1
        print(f"Received photo for user_id {user_id}: {photo_file_id}")
    elif step < len(prompts):
        # Handle text input for other steps
        user_message = update.message.text
        user_data[user_id]['data'].append(user_message)
        user_data[user_id]['step'] += 1
        print(f"Received message for user_id {user_id}: {user_message}")

    # Check if all data is collected
    if user_data[user_id]['step'] == len(prompts):
        tab_name = get_user_tab(user_id)
        if tab_name:
            append_to_sheet(tab_name, user_data[user_id]['data'])
            context.bot.send_message(chat_id=chat_id, text="Thank you! Your data has been recorded.")
            sheet_link = "https://docs.google.com/spreadsheets/d/1AbQLDdr6M8jyeyVV6NMDLZ8yZmBwXEt_FAWWjx4169A/edit?gid=1458540688#gid=1458540688"
            context.bot.send_message(chat_id=chat_id, text=f"You can view your entry here: {sheet_link}")
            print(f"Data recorded for user_id {user_id}: {user_data[user_id]['data']}")
        else:
            context.bot.send_message(chat_id=chat_id, text="Error: Unable to find your tab in the spreadsheet.")
            print(f"Error: Tab not found for user_id {user_id}")
        
        # Reset user data
        del user_data[user_id]
        print(f"Reset user data for user_id {user_id}")
    else:
        # Send the next prompt
        next_prompt = prompts[user_data[user_id]['step']]
        context.bot.send_message(chat_id=chat_id, text=next_prompt)
        print(f"Sent prompt to user_id {user_id}: {next_prompt}")

def send_reminder(chat_id, message):
    """
    Send a reminder message to the specified chat ID.
    
    :param chat_id: The chat ID to send the message to.
    :param message: The reminder message to send.
    """
    bot.send_message(chat_id=chat_id, text=message)

def schedule_reminders():
    """
    Schedule reminders for meal logging.
    """
    # Use the provided chat ID for sending reminders
    chat_id = CHAT_ID

    # Schedule reminders for breakfast, lunch, and dinner in PST
    schedule.every().day.at("10:00").do(send_reminder, chat_id=chat_id, message="Time to log your breakfast!")
    schedule.every().day.at("14:00").do(send_reminder, chat_id=chat_id, message="Time to log your lunch!")
    schedule.every().day.at("21:00").do(send_reminder, chat_id=chat_id, message="Time to log your dinner!")

    while True:
        schedule.run_pending()
        time.sleep(1)

def start_scheduler():
    """
    Start the scheduler in a separate thread.
    """
    scheduler_thread = Thread(target=schedule_reminders)
    scheduler_thread.start()

def main():
    """
    Main function to set up the Telegram bot and register handlers.
    """
    # Create the Updater and pass it your bot's token
    updater = Updater(token=TELEGRAM_TOKEN, use_context=True)

    # Get the dispatcher to register handlers
    dispatcher = updater.dispatcher

    # Register the /start command handler
    dispatcher.add_handler(CommandHandler("start", start))

    # Register a message handler for text messages and photos
    dispatcher.add_handler(MessageHandler(Filters.text | Filters.photo, handle_message))

    # Start the Bot
    updater.start_polling()

    # Start the scheduler
    start_scheduler()

    # Run the bot until you send a signal to stop
    updater.idle()

# Entry point of the script
if __name__ == '__main__':
    main()